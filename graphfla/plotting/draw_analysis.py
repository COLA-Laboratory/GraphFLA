import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.ticker as mplt
import matplotlib.patches as mpatches
import numpy as np
import pandas as pd

from scipy.stats import norm
from ..algorithms import hill_climb_igraph


def draw_epistasis(
    epistasis_df,
    p_threshold=0.05,
    cohen_d_threshold=0.5,
    figsize=(8, 8),
    node_color="#f2f2f2",
    label_font_size=10,
    node_size=500,
    legend_loc="upper right",
    edge_width_scale=2,
):
    """
    Visualize epistatic interactions between all pairs of genetic positions with customizable
    plot formatting.

    Parameters
    ----------
    epistasis_df : pd.DataFrame
        Aggregated epistasis results for all position pairs. This can be generated by the
        `all_pairwise_epistasis` function in the metrics module.

    p_threshold : float, default=0.05
        p-value threshold for significance.

    cohen_d_threshold : float, default=0.5
        Threshold for Cohen's d to define strong interactions.

    figsize : tuple, default=(8, 8)
        Size of the plot figure.

    node_color : str, default='#f2f2f2'
        Color of the nodes in the plot.

    label_font_size : int, default=10
        Font size for the node labels.

    node_size : int, default=500
        Size of the nodes in the plot.

    legend_loc : str, default='upper right'
        Location of the legend.

    edge_width_scale : float, default=2
        Scale factor for edge width based on `average_cohen_d`.

    Returns
    -------
    None
        Displays the plot with enhanced formatting options.
    """

    graph = nx.from_pandas_edgelist(
        epistasis_df,
        source="pos1",
        target="pos2",
        edge_attr=[
            "average_cohen_d",
            "average_mean_diff",
            "most_significant_p",
            "total_mutation_pairs",
        ],
    )

    edge_colors = []
    edge_widths = []

    for u, v, data in graph.edges(data=True):
        if (
            data["average_mean_diff"] > 0
            and data["most_significant_p"] <= p_threshold
            and data["average_cohen_d"] >= cohen_d_threshold
        ):
            rgb = (233, 110, 34)
        elif (
            data["average_mean_diff"] < 0
            and data["most_significant_p"] <= p_threshold
            and data["average_cohen_d"] >= cohen_d_threshold
        ):
            rgb = (50, 143, 157)
        else:
            rgb = (221, 221, 221)

        hex_color = "#{:02x}{:02x}{:02x}".format(*rgb)
        edge_colors.append(hex_color)

        edge_width = (
            data["average_cohen_d"] * edge_width_scale
            if not np.isnan(data["average_cohen_d"])
            else 0.5
        )
        edge_widths.append(edge_width)

    pos = nx.circular_layout(graph, scale=1)
    _, ax = plt.subplots(figsize=figsize)

    nx.draw(
        graph,
        pos,
        edge_color=edge_colors,
        width=edge_widths,
        node_color=node_color,
        node_size=node_size,
        with_labels=True,
        font_size=label_font_size,
        font_weight="bold",
        edgecolors="black",
        ax=ax,
    )

    positive_patch = mpatches.Patch(color="#e96e22", label="Positive Epistasis")
    negative_patch = mpatches.Patch(color="#328f9d", label="Negative Epistasis")
    non_significant_patch = mpatches.Patch(color="#dddddd", label="Non-significant")

    ax.legend(
        handles=[positive_patch, negative_patch, non_significant_patch],
        loc=legend_loc,
        title="Epistasis type",
    )

    ax.axis("off")
    plt.show()


def draw_fdc(
    data: pd.DataFrame,
    distance: str,
    fitness: str,
    confidence_level: float = 0.95,
) -> None:
    """
    Plot the average fitness trend as a function of distance to global optimum.

    Parameters
    ----------
    data : pd.DataFrame
        The input dataset as a pandas DataFrame.
        Contains at least the columns specified by `distance` and `fitness`.

    distance : str
        The column name of the distances to global optimum.

    fitness : str
        The column name of the fitness values.

    confidence_level : float, optional, default=0.95
        The desired confidence level for the interval, expressed as a value between 0 and 1
        (e.g., 0.95 for a 95% confidence interval).

    Returns
    -------
    None
        Displays a plot of the mean trend with shaded confidence intervals.

    Examples
    --------
    >>> import pandas as pd
    >>> data = pd.DataFrame({'distance': [1, 2, 3, 4], 'fitness': [10, 15, 10, 20]})
    >>> fdc_plot(data, distance='distance', fitness='fitness', confidence_level=0.95)
    """
    if not (0 < confidence_level < 1):
        raise ValueError("Confidence level must be a float between 0 and 1.")

    z_value = norm.ppf(1 - (1 - confidence_level) / 2)

    grouped = data.groupby(distance)[fitness]
    mean_values = grouped.mean()
    std_values = grouped.std()
    count_values = grouped.count()
    confidence_intervals = z_value * (std_values / np.sqrt(count_values))

    stats = (
        pd.DataFrame({"Mean": mean_values, "Confidence Interval": confidence_intervals})
        .dropna()
        .reset_index()
    )

    x = stats[distance].astype(float).values
    y_mean = stats["Mean"].astype(float).values
    y_lower = (stats["Mean"] - stats["Confidence Interval"]).astype(float).values
    y_upper = (stats["Mean"] + stats["Confidence Interval"]).astype(float).values

    plt.figure(figsize=(10, 6))
    plt.plot(x, y_mean, label="Mean Fitness", marker="o", linestyle="-")
    plt.fill_between(
        x, y_lower, y_upper, alpha=0.3, label=f"{int(confidence_level * 100)}% CI"
    )
    plt.xlabel(distance.replace("_", " ").title())
    plt.ylabel(fitness.replace("_", " ").title())
    plt.legend()
    plt.grid()
    plt.show()


def draw_fitness_dist(
    fitness: str,
    type: str = "hist",
    bins: int = 50,
    color: str = "skyblue",
    edgecolor: str = "black",
    figsize: tuple = (5, 4),
    log: bool = False,
) -> None:
    """
    Plot the distribution of fitness values in the dataset.

    Parameters
    ----------
    fitness : list or pd.Series or np.ndarray
        The fitness values to plot.

    type : str = {'hist', 'cdf'}, default='hist'
        The type of plot to display. 'hist' for histogram, 'cdf' for cumulative distribution.

    bins : int, default=50
        The number of bins to use for the histogram.

    color : str, default='skyblue'
        The color of the bars in the histogram.

    edgecolor : str, default='black'
        The color of the edges of the bars in the histogram.

    figsize : tuple, default=(5, 4)
        The size of the plot figure.

    log : bool, default=False
        If True, display both axes of the CDF plot on a logarithmic scale.

    Returns
    -------
    None
        Displays a histogram or CDF of the fitness values in the dataset.
    """
    if not isinstance(fitness, pd.Series):
        fitness = pd.Series(fitness)

    if type == "hist":
        plt.figure(figsize=figsize)
        plt.hist(fitness, bins=bins, color=color, edgecolor=edgecolor)
        plt.xlabel("Fitness")
        plt.ylabel("Frequency")
        plt.title(f"Distribution of Fitness Values")
        plt.grid(axis="y", alpha=0.75)
        plt.show()

    elif type == "cdf":
        cdf = fitness.value_counts().sort_index().cumsum() / len(fitness)
        plt.figure(figsize=figsize)
        cdf.plot()
        plt.title("Cumulative Distribution of Fitness Values")
        plt.xlabel("Fitness")
        plt.ylabel("Cumulative Proportion")
        if log:
            plt.xscale("log")
            plt.yscale("log")
        plt.grid()
        plt.show()


def draw_diminishing_return(
    landscape: object,
    sample: int = 10000,
    color: str = "skyblue",
    figsize: tuple = (5, 4),
) -> None:
    """
    Plot the relationship between fitness effects of each mutation and the background fitness
    under which the mutation occurs. This would usually lead to the so-called "diminishing-return"
    pattern observed in evolutionary biology.

    Parameters
    ----------
    landscape : object
        The landscape object containing the graph structure with fitness and delta fitness values.

    sample : int, default=10000
        The number of data points to sample for plotting.

    color : str, default='skyblue'
        The color of the scatter plot points.

    figsize : tuple, default=(5, 4)
        The size of the plot figure.

    Returns
    -------
    None
        Displays a scatter plot of fitness versus delta fitness.
    """
    sample = landscape.n_configs if landscape.n_configs < sample else sample

    logger = []

    for u, v in landscape.graph.edges():
        fitness = landscape.graph.nodes[u]["fitness"]
        delta_fit = landscape.graph.edges[u, v]["delta_fit"]
        logger.append((fitness, delta_fit))

    df = pd.DataFrame(logger, columns=["fitness", "delta_fit"]).sample(sample)

    plt.figure(figsize=figsize)
    plt.scatter(df["fitness"], df["delta_fit"], color=color, alpha=0.8)
    plt.title("Delta Fitness vs Fitness")
    plt.xlabel("Fitness")
    plt.ylabel("Delta Fitness")
    plt.grid(True)
    plt.show()


def draw_ffi(landscape: object, figsize: tuple = (5, 4), min_len: int = 3) -> None:
    """
    Plot all accessible mutational pathways to the global optimum.

    Parameters
    ----------
    landscape : object
        The landscape object containing the graph structure with fitness and delta fitness values.

    min_len : int, default=3
        Minimum length of an adaptive path for it to be considered.

    figsize : tuple, default=(5, 4)
        The size of the plot figure.

    Returns
    -------
    None
        Displays a plot where each grey line indicates an accessible mutation path to the global
        optimum, along with an averaged fitness line.
    """

    data = landscape.get_data()
    idx_to_fitness = data["fitness"].to_dict()
    fitness_list = []

    for i in data.index:
        lo, _, trace = hill_climb_igraph(
            landscape.graph,
            i,
            "delta_fit",
            verbose=0,
            return_trace=True,
        )
        if len(trace) >= min_len and lo == landscape.go_index:
            fitnesses = list([idx_to_fitness[config] for config in trace])
            fitnesses.reverse()
            fitness_list.append(fitnesses)

    path_data = pd.DataFrame(fitness_list).T
    data_array = path_data.values
    mean_values = np.nanmean(data_array, axis=1)
    x_values = np.arange(data_array.shape[0])

    plt.figure(figsize=figsize)

    for column in path_data.columns:
        plt.plot(x_values, path_data[column], color="lightgrey", alpha=0.3)

    plt.plot(x_values, mean_values, color="blue", label="Mean")

    plt.xlabel("Index")
    plt.legend()
    plt.grid()
    plt.show()
